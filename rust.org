* hacking rust ownership
** Stack & Heap(rule of ownership in rust)
 1. stack: FIFO, fast(memory needed is known at compile time)
 2. heap: data of unknow-size needs to be stored during running time,
          but sometime it is difficult to manage;

 Keeping track of *what parts of code are using what data* on the heap, 
 minimizing the amount of *duplicate data* on the heap, and cleaning up 
 *unused data* on the heap so you donâ€™t run out of space are all problems 
 that *ownership* addresses.
 
                --rust book

 the golden rule of rust owner ship:
 A. each value in rust has a variable that's called its owner;
 B. there can be only one owner at a time;
 C. when the owner goes out of scope, the value will be droped;

 #+BEGIN_SRC rust
 fn main() {
    {
        let hello = "hello, cargo";
        println!("the message from me: {}", hello);
    }
    println!("the message is invalid now: {}", hello);
 }
 #+END_SRC

 when we compile the privious code snippet, the output infomation:
 [[file:./graph/owner1.png]]
 we can see once "hello" variable is out of scope, it is dropped!

 let's see other code snippet:
 #+BEGIN_SRC
    let hello = "hello, world";
    let hello1 = hello;
    println!("{}", hello);
 #+END_SRC
 out:
 [[file:./graph/owner2.png]]
 though a warning, but is "hello" can be use after value passing;

 in privious code, hello's value is on stack(a literal string), let's
 see what if it's value is on heap:
 #+BEGIN_SRC
    let hello = String::from("hello world");
    let hello1 = hello;
    println!("{}", hello);
 #+END_SRC
 when we compile the code, we will see:
 [[file:./graph/owner3.png]]
 the error information generated by rust compiler is very clear; so we know that we
 hello is a string literal, Rust is copying the value if *hello* into *hello1*; by when
 using a String type(heap), Rust /moves/ the value instead!

 /*as a general rule, any group of simple scalar values can be Copy,
 and nothing that requires allocation or is some form of resource is Copy*/

 
  
** Why Not Copy Everything?
   in privious chapter, when deal with heap String varible;
       *let hello1 = hello*
   moving data in hello to hello1, and hello is invalid;

   let's see what happens when assain a heap variable to another varible:
   [[file:./graph/owner4.png]]
   what the <<data>> in hello and hello1 varibale is address(point) in stack, which point to
   the real "data" on heap; if *hello* variable is still valid after the assignment, this ab-
   solutely voilates rule #B: "there can be only one owner at a time;"

   at the end of the scope of hello and hello1, if both are valid, then the memory allocated
   on heap will be freed twice, this is a "double free error"!; if hello is invalid after the
   assign, this bad error can never happen!

** But when we do want to copy data on heap?
   #+BEGIN_SRC rust
    let hello = String::from("hello world");
    let hello1 = hello.clone();
    println!("{}", hello);
    println!("{}", hello1);
   #+END_SRC
   use the "clone()" can be expensive, which is why Rust prevents this "deep copying"
   by default.
** What cons and pros of ownership in rust
*** ownership and functions
    #+BEGIN_SRC rust
    fn main() {
        let string = "Hello, World!";
		println!("{:p}", string);
		foo(string);

		let newstr = String::from("Hello, World!");
		println!("{:p}", newstr.as_ptr());
		bar(newstr);
	}

	fn foo(string: &str) {
       println!("{:p}", string);
	}

nnn	fn bar(string: String) {
       println!("{:p}", string.as_ptr())
    }
    #+END_SRC
    when we run the code, get:
    #+BEGIN_SRC
    #+END_SRC
	[[file:./graph/owner5.png]]
    in the *foo* function case, both main and foo have a copy of pointer to
    the stack string, so when "string" in foo is depricated outside foo, the
    string in main is still valid;
    
    but it does not happend to the heap varible; when *newstr* borrowed by
    *bar* depricated when bar function run out, you can never use it in main
    again! this is the time *clone* method is comming:
	#+BEGIN_SRC rust
	let newstr = String::from("Hello, World!");
    println!("{:p}", newstr.as_ptr());
    bar(newstr.clone());
    #+END_SRC
	see what the running result:

    you can check that the pointers inside and outside bar is
    not the same, they deal with different blocks of heap memory.

*** giving ownership by others
    just as function can give onwership to others, they can
    get the ownership from other place:
    #+BEGIN_SRC rust
    fn main() {
        let str = give_own();
		println!("{:p}", str.as_ptr());
    }

	fn give_own() -> String {
        let str = String::from("hello, rust");
		println!("{:p}", str.as_ptr());
		str
    }
    #+END_SRC
	running result of this code snippet:
    [[file:./graph/owner7.png]]
  
*** first take and then give out:
    a function can first take the ownership from other place and finally
    given the ownership out:
	#+BEGIN_SRC rust
    fn main() {
    let str = give_own();
    println!("{:p}", str.as_ptr());

    let rstr = borrow_then_payback(str);
    println!("{:p}", rstr.as_ptr());
	}

	fn give_own() -> String {
        let str = String::from("hello, rust");
		println!("{:p}", str.as_ptr());
		str
    }

	fn borrow_then_payback(str: String) -> String {
        println!("{:?}", str.as_ptr());
		str
    }
    #+END_SRC
	code running result:
    [[file:./graph/owner8.png]]
    we can trace the ownership trace of this programe:
	give_own --> main --> borrow_the_payback --> main
    we can see the same print result in the output, because they all deal with
    the same block of heap memory!

	but this taking-payback usage is so quite annoying. In rust,
    we can bypass it using *references*;

*** reference
    a code snippet:
    #+BEGIN_SRC rust
    fn main() {
        let str = String::from("hello rust");
		println!("{:p}", str.as_ptr());
		borrow(&str);
		println!("{:p}", str.as_ptr());
	}

	fn borrow(str: &String) {
        println!("{:p}", str.as_ptr())
	}
    #+END_SRC
	this is the running result:
    [[file:./graph/owner9.png]]
    we can see in main. str is still valid after borrow(&str) happend;
    and same addresses in the output tell they all point to the same
    block of heap address;
*** mutability
**** mutable variable
    #+BEGIN_SRC rust
    let mut str = String::from("hello rust");
    println!("{:p}", str.as_ptr());
    str.push_str(", jump out of window");
    println!("{:p}", str.as_ptr());
    #+END_SRC
    rust use *mut* keyword tell a variable can be mutated;
    [[file:./graph/owner10.png]]
    in the running result, we can see the heap data is mutated,
    the different address show that some memory reallocation happened!

**** mutable reference
    #+BEGIN_SRC rust
    fn main() {
        let mut str = String::from("hello rust");
		println!("{:p}", str.as_ptr());
		mutate(&mut str);
		println!("{:p}", str.as_ptr());
    }

	fn mutate(str: &mut String) {
        println!("{:p}", str.as_ptr());
		str.push_str(", if you can jump out of this superficial reality.");
		println!("{:p}", str.as_ptr());
	}
    #+END_SRC
    the running result:
    [[file:./graph/owner11.png]]
    the result shows that main still have the onwership of the
    mutable variable and the function had change the value of
    the variable;

**** how rust handle race conditions?
	 at any given time, you can have either one mutable reference
     [so no other process can change the value behind the reference]
     or any number of immutable references;

     rust can prevent data races at compile time by this rule;
     rust not allowed code with data race condition.

   	


    
*** dangling references
    #+BEGIN_SRC rust
    fn main() {
        let string = dangling();
	}

	fn dangling() -> &String {
        let str = String::from("dangling string");
		println!("{}", str);
		&str
	}
    #+END_SRC
	function dangling return a refercence of a variable,
    but the lifetime of the varible will be ending when
    the function finish! so the reference point to something
    unknow! let's see what the rust compiler tell us:
    [[file:./graph/owner12.png]]
    "no value for it to be borrowed from";
