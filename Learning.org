* Clojure
** DONE build, running and the REPL
** DONE install jvm and Leiningen
   choco install jvm1.8
   [[http://leiningen.org][leiningen site]]
   [[https://djpowell.github.io/leiningen-win-installer/][install leiningen on windows mechine]]
   after leiningen installed, enter
   *$lein new app hello-world*
   to create a clojure project

   then cd into hello-world, enter
   *$lein deps*
   to load dependences file form centrol

** DONE let emacs dance with clojure
Table 1: Clojure Buffer Key Bindings
| Keys	        | Description                                                                        |
|-----------------+------------------------------------------------------------------------------------|
| C-c M-n M-n	 | Switch to namespace of current buffer.                                             |
| C-x C-e	     | Evaluate expression immediately preceding point.                                   |
| C-c C-k	     | Compile current buffer.                                                            |
| C-c C-d C-d	 | Display documentation for symbol under point.                                      |
| M-. and M-,	 | Navigate to source code for symbol under point and return to your original buffer. |
| C-c C-d C-a	 | Apropros search; find arbitrary text across function names and documentation.      |

Table 2: CIDER Buffer Key Bindings
| Keys	       | Description                     |
|----------------+---------------------------------|
| C-↑, C-↓	 | Cycle through REPL history.     |
| C-enter	    | Close parentheses and evaluate. |


| Keys             | Description                                                              |
|------------------+--------------------------------------------------------------------------|
| M-x paredit-mode | Toggle paredit mode.                                                     |
| M-(              | Surround expression after point in parentheses (paredit-wrap-round).     |
| C-→             | Slurp; move closing parenthesis to the right to include next expression. |
| C-←             | Barf; move closing parenthesis to the left to exclude last expression.   |
| C-M-f/C-M-b      | Move to the opening/closing parenthesis.                                 |

** DONE Clojure basic data structure
All of Clojures data structures are immutable, meaning you cant change them in place.
*** Numbers in Clojure
*** Strings in Clojure
*** Maps in Clojure
*** Keywords in Clojure
*** Vectors in Clojure
*** Lists in Clojure
*** Function:
**** function arity overloading

#+BEGIN_SRC elisp 
(defn multi-arity
 ;; 3-arity arguments and body
 ([first-arg second-arg third-arg]
   (str first-arg second-arg third-arg))
 ([first-arg second-arg]
   (str first-arg second-arg))
 ([first-arg]
   (str first-arg)))
#+END_SRC

Use arity overloading provide default values for arguments:
#+BEGIN_SRC elisp
(defn x-chop
   "Describe the kind of chop you're inflicting on someone"
   ([name chop-type]
      (str "I " chop-type "chop " name "! Take that!"))
   ([name]
      (x-chop name "karate")))
#+END_SRC

Varible arguments:

#+BEGIN_SRC elisp
(defn codger-communication
   [whippersnapper]
   (str "Get off my lawn, " whippersnapper "!!!"))

(defn codger
   [& whippersnappers]
   (map codger-communication whippersnappers))
#+END_SRC

running it:

(codger "Billy" "Anne-Marie" "The Incredible Bulk")
("Get off my lawn, Billy!!!"
 "Get off my lawn, Anne-Marie!!!"
 "Get off my lawn, The Incredible Bulk!!!")

**** function destruction

** DONE Clojure core functions
** TODO functional programming in Clojure
side effects are potentially harmful. because they introduce uncertainty about what the names in
your code are reffering to.

Functions with size effects, on the other hand, place more of a burden on your mind grapes.
Not only these functions are rot, but those components use these functions. They are infected by.

How can you progamming without size effect? This is really a big suege!! Really BIG!!
*** Living with (Clojure) Immutable Data Structure
Clojure use recursion work around the side effect:
#+BEGIN_SRC Clojure
(defn my-sum
             ([vals] (my-sum vals 0))
             ([vals accumulating-total]
                 (if (empty? vals)
                   accumulating-total
                   (my-sum (rest vals) (+ (first vals) accumulating-total)))))
#+END_SRC

Clojure do not use Attribute Mutation commonly used in some OO programming languange.
Such as C++, java. Alternativly use function composition to implement the Mutation effects!

example:
#+BEGIN_SRC 
(defn clean
             [text]
             (s/replace (s/trim text) #"lol" "LOL"))
#+END_SRC
it is so simple to write programe with function composition, just pass return value of one function
to another function. Compare with OO languanges, the classes in OO languanges is to protect date, 
they just want to fight against unwanted modification of private data. Just as they protect the data,
the functions deal with the data are also been protected! This is often unnessensery.

let's seen the two powerful weapons of Clojure:
1) decoupling functions and data, let them free from each other!
2) programming to a small set of abstractions, this will grow into more
   reusable, composable code!

*** Cool Things to do with Pure functions
Data can be derived into new data in Clojure, but what about function? Can you Drive new functions from exist
pure functions? Let's try it!

**** Let's refresh the memory of "partial"
(defn hundred-times (partial * 100))
(hundred-times 100)

**** Use comp to composite functions
#+BEGIN_SRC 
(def character
     {:name "Smooches McCutes"
      :attributes {:intelligence 10
                   :strength 4
                   :dexterity 5}})


(def c-int (comp :intelligence :attributes))
(def c-str (comp :strength :attributes))
(def c-dex (comp :dexterity :attributes))

(c-int character)
(c-str character)
(c-dex character)
#+END_SRC

* Emacs Org
** DONE Deal with table
*** Preparing tables for export
	
** Emacs org mode for GTD(Get Things Done)
** TODO Use emacs prepare blogs	
* Golang
** Viper(小蛇)
*** What is Viper and What you can play with viper?
Viper is a complete configuration solution for Go applications including 12-Factor apps. It is designed to work within an application, and can handle all types of configuration needs and formats. It supports:

1. setting defaults
2. reading from JSON, TOML, YAML, HCL, envfile and Java properties config files
3. live watching and re-reading of config files (optional)
4. reading from environment variables
5. reading from remote config systems (etcd or Consul), and watching changes
6. reading from command line flags
7. reading from buffer
8. setting explicit values

Viper can be thought of as a registry for all of your applications configuration needs.

